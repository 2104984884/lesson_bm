### 闭包
闭包 **作用域是声明时就决定**  符合**词法作用域**
普通函数this指向**调用时决定**  符合**动态作用域**
**箭头函数与普通函数相反** 与闭包相似 规则为**词法作用域**

### 执行上下文
- 全局上下文 —— 全局代码所处的环境，不在函数中的代码都在全局执行上下文中
- 函数上下文 —— 在函数**调用时**创建的上下文
- 创建阶段 —— 执行上下文的初始化状态，此时一行代码都还没有执行，只是做了一些准备工作
- 执行阶段 —— 逐行执行脚本里的代码  执行上下文在执行阶段里其实始终是处在一个**动态**
自由变量的查找是沿着**作用域链(定义位置)**,而**不是调用栈** 当代码执行到函数A的外部作用域(外部上下文)时，函数A的上下文还没有被推入栈，所以查找不到函数A中的内容 ，而当函数A执行完毕 代码退回外部作用域，函数A的上下文已经出栈/被销毁，所以此时当然也无法查找到函数A中的内容

### 原型 
**几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例**，除了 **Object.prototype**（当然，如果我们手动用 **Object.create(null)** 创建一个没有任何原型的对象，那它也不是 Object 的实例）。

### this指向
- **立即执行函数**（IIFE）
- **setTimeout** 中传入的函数
- **setInterval** 中传入的函数
这三种特殊情况下  **this都会100%指向window**

### 严格模式
```js
'use strict'
console.log(this) // 直接在全局代码里尝试去拿 this
-----------------------
'use strict'

var name = 'BigBear'

var me = {
  name: 'xiuyan',
  hello: function() {
    // 全局作用域下实现的延时函数
    setTimeout(function() {
      console.log(`你好，我是${this.name}`)
    })
  }
}

me.hello() // 你好，我是BigBear
```
像这样**处于全局代码中的 this**， 不管它是否处于严格模式下，它的 **this 都指向 Window**

### 内存管理机制
- 内存的生命周期
  1. 分配内存
  2. 内存读写
  3. 内存释放
- 基本数据类型放在**栈中存储**
- 引用数据类型(如Object、Array、Function )放在**堆中存储**
- 内存泄漏原因
  1. 忘记清除的 setInterval 和 setTimeout
  2. 清除不当的 DOM  removeChild()
